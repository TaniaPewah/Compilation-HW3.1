%{
    #include "parser.hpp"

    #include<iostream>
    using namespace std;

    int yylex();
    int yyerror(char const*);
    SymbolTable symbolTable;
    void checkOpTypes(Node*, Node*, int);
    void exitOnFalse(bool);

%}

%locations

%token VOID INT BYTE B BOOL ENUM
%token TRUE FALSE
%token RETURN IF ELSE WHILE BREAK CONTINUE
%token PRECOND
%token SC COMMA
%token LPAREN RPAREN LBRACE RBRACE
%token ID NUM STRING

%right NOT
%left AND
%left OR
%right ASSIGN

// relop
%left EQUAL
%left NOTEQUAL
%nonassoc LESS
%nonassoc GREATER
%nonassoc LESSEQUAL
%nonassoc GREATEREQUAL

// binop
%left ADD
%left SUB
%left DIV
%left MUL

%%

Program : Enums Funcs {
                          if (!symbolTable.hasMain) {
                              output::errorMainMissing();
                              exit(0);
                          }
                      }
;

Enums : %empty
    | EnumDecl Enums
;

EnumDecl : ENUM ID {
                       if (symbolTable.isAlreadyDefined(((IdNode*)$2)->name)) {
                           output::errorDef($2->lineno, ((IdNode*)$2)->name);
                           exit(0);
                       }
                   } LBRACE EnumeratorList RBRACE SC {
                            $$ = new EnumDeclNode(((IdNode*)$2)->name, $2->lineno);
                            exitOnFalse(symbolTable.addEnum((IdNode*)$2, ((EnumeratorListNode*)$4)->enums));
                       }
;

EnumeratorList : Enumerator {
                            $$ = new EnumeratorListNode(((EnumeratorNode*)$1)->name, $1->lineno);
                        }
    | EnumeratorList COMMA Enumerator {
                                    $$ = $3;
                                    ((EnumeratorListNode*)$$)->add(((EnumeratorNode*)$1)->name, $1->lineno);
                                }
;

Enumerator : ID {
                    $$ = new EnumeratorNode(((IdNode*)$1)->name, $1->lineno);
                }
;

Funcs : %empty
    | FuncDecl Funcs {
                        $$ = $2;
                     }
;

FuncDecl : RetType ID LPAREN Formals RPAREN {
                if (symbolTable.isAlreadyDefined(((IdNode*)$2)->name)) {
                    output::errorDef($2->lineno, ((IdNode*)$2)->name);
                    exit(0);
                }
                exitOnFalse(symbolTable.addFunction((IdNode*)$2, ((TypeNode*)$1)->type, ((FormalsNode*)$4)->types, ((FormalsNode*)$4)->names));
                $$ = new StatementNode();
            } LBRACE Statements RBRACE { symbolTable.endScope(); }
;

RetType : Type { $$ = $1; }
        | VOID { $$ = $1; }
;

Formals : %empty {
            $$ = new FormalsNode();
        }
    | FormalsList
        {
            $$ = new FormalsNode(((FormalsListNode*)$1)->types, ((FormalsListNode*)$1)->names, $1->lineno);
        }
;

FormalsList : FormalDecl {
                $$ = new FormalsListNode(((FormalDeclNode*)$1)->type, ((FormalDeclNode*)$1)->name, $1->lineno);
            }

        | FormalDecl COMMA FormalsList {
                $$ = $3;
                ((FormalsListNode*)$$)->add(((FormalDeclNode*)$1)->type, ((FormalDeclNode*)$1)->name, $1->lineno);
            }
;

FormalDecl : Type ID
            {
                if (symbolTable.isAlreadyDefined(((IdNode*)$2)->name)) {
                    output::errorDef($2->lineno, ((IdNode*)$2)->name);
                    exit(0);
                }
                exitOnFalse(symbolTable.addVar((IdNode*)$2, ((TypeNode*)$1)->type));
                $$ = new FormalDeclNode(((TypeNode*)$1)->type, ((IdNode*)$2)->name, $2->lineno);
            }
;

Statements : Statement { $$ = $1; }
        | Statements Statement { $$ = $2; }
;

Statement : LBRACE NewScope Statements RBRACE {  }
    | Type ID SC {  }
    | EnumType ID SC {  }
    | EnumDecl {  }
    | Type ID ASSIGN Exp SC {  }
    | EnumType ID ASSIGN Exp SC {  }
    | ID ASSIGN Exp SC {  }
    | Call SC {  }
    | RETURN SC {  }
    | RETURN Exp SC {  }
    | IF LPAREN Exp RPAREN Statement %prec NO_ELSE {  }
    | IF LPAREN Exp RPAREN Statement ELSE Statement {  }
    | WHILE MarkerWhileOn LPAREN Exp RPAREN Statement {  }
    | BREAK SC {  }
    | CONTINUE SC {  }
;

EnumType : ENUM ID {
                        if (!symbolTable.isEnumDefined(((IdNode*)$2)->name)) {
                            output::errorUndefEnum($2->lineno, ((IdNode*)$2)->name);
                            exit(0);
                        }

                   }
;

MarkerWhileOn : %empty {
                            symbolTable.newInnerScope(true /*isWhileScope*/);
                        }
;

NewScope : %empty
                    {
                        symbolTable.newInnerScope();
                    }
;

Call : ID LPAREN ExpList RPAREN
                        {
                            if (!symbolTable.isDefinedFunction(((IdNode*)$1)->name)) {
                                output::errorUndefFunc($1->lineno, ((IdNode*)$1)->name);
                                exit(0);
                            }

                            vector<Types> args = symbolTable.getFunctionArgs(((IdNode*)$1)->name);
                            if (!((ExpListNode*)$3)->compareType(args)) {
                                vector<string> argTypes = typeToStringVector(args);
                                output::errorPrototypeMismatch($1->lineno, ((IdNode*)$1)->name, argTypes);
                                exit(0);
                            } 
                        
                            $$ = new CallNode(symbolTable.getType(((IdNode*)$1)->name), $1->lineno);
                        }
                    | ID LPAREN RPAREN
                        {
                            if (!symbolTable.isDefinedFunction(((IdNode*)$1)->name)) {
                                output::errorUndefFunc($1->lineno, ((IdNode*)$1)->name);
                                exit(0);
                            }

                            vector<Types> args = symbolTable.getFunctionArgs(((IdNode*)$1)->name);
                            if (args.size() != 0) {
                                vector<string> argTypes = typeToStringVector(args);
                                output::errorPrototypeMismatch($1->lineno, ((IdNode*)$1)->name, argTypes);
                                exit(0);
                            } 
                        
                            $$ = new CallNode(symbolTable.getType(((IdNode*)$1)->name), $1->lineno);
                        }
;

ExpList : Exp {  }
    | Exp COMMA ExpList {  }
;

Type : INT
        { $$ = $1; }
    | BYTE
        { $$ = $1; }
    | BOOL
        { $$ = $1; }
;

Exp : LPAREN Exp RPAREN {  }
    | Exp ADD Exp {  }
    | Exp SUB Exp {  }
    | Exp MUL Exp {  }
    | Exp DIV Exp {  }
    | ID {  }
    | Call {  }
    | NUM {  }
    | NUM B {  }
    | STRING {   }
    | TRUE {   }
    | FALSE {  }
    | NOT Exp {  }
    | Exp AND Exp {  }
    | Exp OR Exp {  }
    | Exp EQUAL Exp {  }
    | Exp NOTEQUAL Exp {  }
    | Exp LESS Exp {  }
    | Exp GREATER Exp {  }
    | Exp LESSEQUAL Exp {  }
    | Exp GREATEREQUAL Exp {  }
    | LPAREN Type RPAREN Exp {  }

%%

int main()
{
    yyparse();
    symbolTable.endScope();
    return 0;
}

void exitOnFalse(bool b) {
    if (!b) {
        exit(0);
    }
}
